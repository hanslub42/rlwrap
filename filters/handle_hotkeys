#!/usr/bin/env perl

use lib ($ENV{RLWRAP_FILTERDIR} or ".");
use RlwrapFilter;
use strict;
use POSIX qw(:signal_h);
use File::Slurp;



# change the table below if you like, but don't forget to bind the corresopnding keys  to 'rlwrap-hotkey' in yout .inputrc
my $keymap =
{ "y" => \&yank_clipboard,
  "n" => \&edit_history, 
  "t" => \&date_in_echo_area,
};  


############################################ The Filter #################################################

my $filter = new RlwrapFilter;
my $name = $filter -> name;

$filter -> help_text("Usage: rlwrap -z $name <command>\n".
		     "handle hotkeys (but only if bound to 'rlwrap-hotkey' in your .inputrc):\n" .
                     document_all_hotkeys());


$filter -> hotkey_handler(\&hotkey);

$filter -> run;

  
sub hotkey {
    my ($key, @other_params) = @_;                                  # key = e.g.  "<CTRL-Y>" 
    my $handler = $keymap -> {uncontrol($key)};
    return ($key, @other_params) unless $handler; # a filter further downstream may want to handle this hotkey 
    my @result = &$handler(0, @other_params);
    return @result;
}


############################# A few handlers ###############################################


sub yank_clipboard {
  my ($doc, $prefix, $postfix, @boring) = @_;
  $doc and return "insert from clipboard";
  my $selection = safe_backtick(qw(xsel -o));
  return ("", $prefix . $selection, $postfix, @boring);
}


sub date_in_echo_area {
  my ($doc, @boring) = @_;
  $doc and return "show current time in echo area";
  my $date = safe_backtick(qw(date +%H:%M));
  return ("($date) ", @boring);
}

sub edit_history {
  my ($doc, $prefix, $postfix, $history, $histpos) = @_;
  $doc and return "edit current history";  
  my $editfile = ($ENV{TMP} || $ENV{TEMP} || "/tmp") . "/history.$$.txt";
  my $lineno = $histpos + 1;
  my $colno = length($prefix) + 1;
  $history ||= " "; #writefile crashes  if called on an empty string....
  write_file($editfile , $history);
  my $editor = $ENV{RLWRAP_EDITOR} || "vi +%L";
  $editor =~ s/%L/$lineno/;
  $editor =~ s/%C/$colno/;
  system("$editor $editfile");
  my @lines = read_file($editfile);
  my (@new_history, $counter, $empty_counter, $last_counter, $last_empty_counter);
  foreach my $line (@lines) {
    $line =~ s/\t//g;
    $line =~ s/^\s+//;
    $line =~ s/\s+$//;
    if ($line) {
      if ($empty_counter > 0) {
        # remember position of last line after an empty line,
        # and the number of empty lines:
        ($last_counter, $last_empty_counter) = ($counter, $empty_counter); 
      }
      $empty_counter = 0;
      $counter++; # We count 0-based, so increment only now
      push @new_history, $line;
    } else {
      $empty_counter++;
    }
  }
  if ($last_empty_counter) {
    $histpos = $last_counter;
    $prefix = $new_history[$histpos];
    $postfix = "";
  }
  return ("", $prefix, $postfix, (join "\n", @new_history), $histpos);
 }   

############################## helper functions #########################################################

sub document_all_hotkeys {
    my $doclist;
    foreach my $k  ("a".."z") {
        if ((my $handler = $keymap -> {$k})) {
            $doclist .= "CTRL+$k:   " . &$handler(1) . "\n";
        }
    }
    my $inputrc = "$ENV{HOME}/.inputrc";
    $doclist .= "Currently bound hotkeys in $inputrc:\n";
    $doclist .= safe_backtick("grep", "rlwrap-hotkey", $inputrc);
    return $doclist;
}


sub safe_backtick {
    my @command_line = @_;
    my $command_line = join ' ', @command_line;
    open my $pipefh, '-|' or exec @command_line or die "$command_line failed: $!\n";
    my $result;
    { local $/;               # slurp all output in one go
      $result = <$pipefh>; 
      close $pipefh;
    }
    chomp $result;            # chop off last newline
    return $result
}


# give back corresponding CTRL-key. E.g: control("m") = "\0x13"
sub control {
    my ($key) = @_;
    $key = lc $key;
    die "Key '$key' should be one of a ..z\n" unless $key =~ /[a..z]/; # is this too strict?
    return pack("c", unpack("c", lc $key) - 64);
}

sub uncontrol {
    my ($key) = @_;
    return  lc pack("c", unpack("c", $key) + 64);
}
