.\" Automatically generated by Pod::Man 4.07 (Pod::Simple 3.32)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RlwrapFilter 3pm"
.TH RlwrapFilter 3pm "2016-07-26" "perl v5.24.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RlwrapFilter \- Perl class for rlwrap filters
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use lib $ENV{RLWRAP_FILTERDIR};
\&  use RlwrapFilter;
\&
\&  $filter = new RlwrapFilter;
\&
\&  $filter \-> output_handler(sub {s/apple/orange/; $_}); # re\-write output
\&  $filter \-> prompt_handler(\e&pimp_the_prompt); # change prompt
\&  $filter \-> history_handler(sub {s/with password \ew+/with password ****/; $_}); # keep passwords out of history
\&
\&  $filter \-> run;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBrlwrap\fR (1) (<http://utopia.knoware.nl/~hlub/uck/rlwrap>) is a tiny
utility that sits between the user and any console command, in order
to bestow readline capabilities (line editing, history recall) to
commands that don't have them.
.PP
Since version 0.32, rlwrap can use filters to script almost every
aspect of rlwrap's interaction with the user: changing the history,
re-writing output and input, calling a pager or computing completion
word lists from the current input.
.PP
\&\fBRlwrapFilter\fR makes it very simple to write rlwrap
filters in perl. A filter only needs to instantiate a RlwrapFilter
object, change a few of its default handlers and then call its 'run'
method.
.PP
There is also a Python 3 module \fBrlwrapfilter.py\fR, distributed
together with \fBrlwrap\fR, that provides  more or less the same \s-1API\s0 as
its \fBperl\fR counterpart.
.SH "PUBLIC METHODS"
.IX Header "PUBLIC METHODS"
.SS "\s-1CONSTRUCTOR\s0"
.IX Subsection "CONSTRUCTOR"
.ie n .IP "$f = new RlwrapFilter" 4
.el .IP "\f(CW$f\fR = new RlwrapFilter" 4
.IX Item "$f = new RlwrapFilter"
.PD 0
.ie n .IP "$f = RlwrapFilter \-> new(prompt_handler => sub {""Hi! > ""}, minimal_rlwrap_version => ""0.35"", ...)" 4
.el .IP "\f(CW$f\fR = RlwrapFilter \-> new(prompt_handler => sub {``Hi! > ''}, minimal_rlwrap_version => ``0.35'', ...)" 4
.IX Item "$f = RlwrapFilter -> new(prompt_handler => sub {Hi! > }, minimal_rlwrap_version => 0.35, ...)"
.PD
Return a new RlwrapFilter object.
.SS "\s-1SETTING/GETTING HANDLERS\s0"
.IX Subsection "SETTING/GETTING HANDLERS"
Handlers are user-defined callbacks that specify one or more of an
RlwrapFilter object's handler methods (handle_input, handle_prompt)
They get called from the 'run' method in response to a message sent
from \fBrlwrap\fR.  Messages consist of a tag indicating which handler
should be called (e.g. \s-1TAG_INPUT, TAG_HISTORY\s0) and the message
text. Usually, a filter overrides only one or at most two methods.
.PP
\fI\s-1CALLING CONVENTIONS\s0\fR
.IX Subsection "CALLING CONVENTIONS"
.PP
In many cases (e.g. \s-1TAG_INPUT, TAG_OUTPUT, TAG_PROMPT\s0) the message
text is a simple string. Their handlers are called with the message
text (i.e. the un-filtered input, output, prompt) as their only
argument. For convenience, \f(CW$_\fR is set to the same value. They should
return the re-written message text.
.PP
Some handlers (those for \s-1TAG_COMPLETION\s0 and \s-1TAG_HOTKEY\s0) are a little
more complex: their message text (accessible via \f(CW$_\fR) is a
tab-separated list of fields; they get called with multiple arguments
and are evaluated in list context.
.PP
The message handlers are called in a fixed cyclic order: prompt,
completion, history, input, echo, output, prompt, ... etc ad
infinitum. Rlwrap may always skip a handler when in direct mode; on
the other hand, completion and output handlers may get called more
than once in succession. If a handler is left undefined, the result is
as if the message text were returned unaltered.
.PP
It is important to note that the filter, and hence all its handlers,
are bypassed when \fIcommand\fR is in direct mode, i.e. when it asks for
single keystrokes (and also, for security reasons, when it doesn't
echo, e.g. when asking for a password). If you don't want this to happen, use
\&\fBrlwrap \-a\fR to force \fBrlwrap\fR to remain in readline mode and to
apply the filter to \fIall\fR of \fIcommand\fR's in\- and output. This will
make editors and pagers (which respond to single keystrokes) unusable,
unless you use rlwrap's \fB\-N\fR option (linux only)
.PP
The getters/setters for the respective handlers are listed below:
.ie n .IP "$handler = $f \-> prompt_handler, $f \-> prompt_handler(\e&handler)" 4
.el .IP "\f(CW$handler\fR = \f(CW$f\fR \-> prompt_handler, \f(CW$f\fR \-> prompt_handler(\e&handler)" 4
.IX Item "$handler = $f -> prompt_handler, $f -> prompt_handler(&handler)"
The prompt handler re-writes prompts and gets called when rlwrap
decides it is time to \*(L"cook\*(R" the prompt, by default some 40 ms after
the last output has arrived. Of course, \fBrlwrap\fR cannot read the mind
of \fIcommand\fR, so what looks like a prompt to \fBrlwrap\fR may actually
be the beginning of an output line that took \fIcommand\fR a little
longer to formulate. If this is a problem, specify a longer \*(L"cooking\*(R"
time with rlwrap's \fB\-w\fR option, use the \fBprompts_are_never_empty\fR
method or \*(L"reject\*(R" the prompt (cf. the \fBprompt_rejected\fR method)
.ie n .IP "$handler = $f \-> completion_handler, $f \-> completion_handler(\e&handler)" 4
.el .IP "\f(CW$handler\fR = \f(CW$f\fR \-> completion_handler, \f(CW$f\fR \-> completion_handler(\e&handler)" 4
.IX Item "$handler = $f -> completion_handler, $f -> completion_handler(&handler)"
The completion handler gets called with three arguments: the entire input
line, the prefix (partial word to complete), and rlwrap's own completion list.
It should return a (possibly revised) list of completions.
As an example, suppose the user has typed \*(L"She played for
A<\s-1TAB\s0>\*(R". The handler will be called like this:
.Sp
.Vb 1
\&     myhandler("She played for A", "A", "Arsenal", "Arendal", "Anderlecht")
.Ve
.Sp
it could then return a list of stronger clubs: (\*(L"Ajax\*(R", \*(L"\s-1AZ67\*(R",  \s0\*(L"Arnhem\*(R")
.ie n .IP "$handler = $f \-> history_handler, $f \-> history_handler(\e&handler)" 4
.el .IP "\f(CW$handler\fR = \f(CW$f\fR \-> history_handler, \f(CW$f\fR \-> history_handler(\e&handler)" 4
.IX Item "$handler = $f -> history_handler, $f -> history_handler(&handler)"
Every input line is submitted to this handler, the return value is put
in rlwrap's history. Returning an empty or undefined value will keep
the input line out of the history.
.ie n .IP "$handler = $f \-> hotkey_handler, $f \-> hotkey_handler(\e&handler)" 4
.el .IP "\f(CW$handler\fR = \f(CW$f\fR \-> hotkey_handler, \f(CW$f\fR \-> hotkey_handler(\e&handler)" 4
.IX Item "$handler = $f -> hotkey_handler, $f -> hotkey_handler(&handler)"
If the user presses a key that is bound to \*(L"rlwrap_hotkey\*(R" in \fB.inputrc\fR
the handler is called with three arguments: the hotkey, the prefix (i.e.
the part of the current input line before the cursor), and the remaining part of
the input line (postfix). It should return a list consisting of a possibly
empty message (to be displayed in readline's echo area), the re-writen prefix and
ditto postfix. Example:
if the current input line is  \*(L"pea soup\*(R" (with the cursor on the
space), and the user presses \s-1CTRL+P,\s0 which happens to be bound to \*(L"rlwrap-hotkey\*(R"
in \fB.inputrc\fR, the handler is called like this:
.Sp
.Vb 1
\&    my_handler(16, "pea", " soup") # 16 = CTRL\-P
.Ve
.Sp
If you prefer peanut soup, the handler should return
.Sp
.Vb 1
\&    ("Mmmm!", "peanut", " soup")
.Ve
.Sp
after which the input line will be \*(L"peanut soup\*(R" (with the cursor
again on the space) and the echo area will display \*(L"Mmmm!\*(R"
.ie n .IP "$handler = $f \-> input_handler, $f \-> input_handler(\e&handler)" 4
.el .IP "\f(CW$handler\fR = \f(CW$f\fR \-> input_handler, \f(CW$f\fR \-> input_handler(\e&handler)" 4
.IX Item "$handler = $f -> input_handler, $f -> input_handler(&handler)"
Every input line is submitted to this handler, The handler's return
value is written to \fIcommand\fR's pty (pseudo-terminal).
.ie n .IP "$handler = $f \-> echo_handler, $f \-> echo_handler(\e&handler)" 4
.el .IP "\f(CW$handler\fR = \f(CW$f\fR \-> echo_handler, \f(CW$f\fR \-> echo_handler(\e&handler)" 4
.IX Item "$handler = $f -> echo_handler, $f -> echo_handler(&handler)"
The first line of output that is read back from \fIcommand\fR's pty is
the echo'ed input line. If your input handler alters the input line,
it is the altered input that will be echo'ed back. If you don't want
to confuse the user, use an echo handler that returns your original
input.
.Sp
If you use rlwrap in \-\-multi\-line mode, additional echo lines will
have to be handled by the output handler
.ie n .IP "$handler = $f \-> output_handler, $f \-> output_handler(\e&handler)" 4
.el .IP "\f(CW$handler\fR = \f(CW$f\fR \-> output_handler, \f(CW$f\fR \-> output_handler(\e&handler)" 4
.IX Item "$handler = $f -> output_handler, $f -> output_handler(&handler)"
All \fIcommand\fR output after the echo line is submitted to the output
handler (including newlines). This handler may get called many times in succession,
dependent on the size of \fIcommand\fR's \fIwrite()\fR calls, and the whims of
your system's scheduler. Therefore your handler should be prepared to
rewrite your output in \*(L"chunks\*(R", where you even don't have the
guarantee that the chunks contain entire unbroken lines.
.Sp
If you want to handle \fIcommand\fR's entire output in one go, you can
specify an output handler that returns an empty string, and then use
\&\f(CW$filter\fR \-> cumulative_output in your prompt handler to send the
re-written output \*(L"out-of-band\*(R" just before the prompt:
.Sp
.Vb 1
\&    $filter \-> output_handler(sub {""});
\&
\&    $filter \-> prompt_handler(
\&                  sub{ $filter \-> send_output_oob(mysub($filter \-> cumulative_output));
\&                       "Hi there > "
\&                     });
.Ve
.Sp
Note that when rlwrap is run in \-\-multi\-line mode the echo handler will still
only handle the first echo line.  The remainder will generally
be echoed back preceded by a continuation prompt; it is up to the
output handler what to do with it.
.ie n .IP "$handler = $f \-> message_handler, $f \-> message_handler(\e&handler)" 4
.el .IP "\f(CW$handler\fR = \f(CW$f\fR \-> message_handler, \f(CW$f\fR \-> message_handler(\e&handler)" 4
.IX Item "$handler = $f -> message_handler, $f -> message_handler(&handler)"
This handler gets called (as handler($message, \f(CW$tag\fR)) for every
incoming message, and every tag (including out-of-band tags), before
all other handlers. Its return value is ignored, but it may be useful
for logging and debugging purposes. The \f(CW$tag\fR is an integer that can be
converted to a tag name by the 'tag2name' method
.SS "\s-1OTHER METHODS\s0"
.IX Subsection "OTHER METHODS"
.ie n .IP "$f \-> help_text(""Usage..."")" 4
.el .IP "\f(CW$f\fR \-> help_text(``Usage...'')" 4
.IX Item "$f -> help_text(Usage...)"
Set the help text for this filter. It will be displayed by rlwrap \-z
<filter>. The second line of the help text is used by \f(CW\*(C`rlwrap \-z listing\*(C'\fR;
it should be a short description of what the filter does.
.ie n .IP "$f \-> minimal_rlwrap_version(""x.yy"")" 4
.el .IP "\f(CW$f\fR \-> minimal_rlwrap_version(``x.yy'')" 4
.IX Item "$f -> minimal_rlwrap_version(x.yy)"
Die unless rlwrap is version x.yy or newer
.ie n .IP "$dir = $f \-> cwd" 4
.el .IP "\f(CW$dir\fR = \f(CW$f\fR \-> cwd" 4
.IX Item "$dir = $f -> cwd"
return the name of \fIcommand\fR's current working directory. This uses
the /proc filesystem, and may only work on newer linux systems (on
older linux and on Solaris, it will return something like
\&\*(L"/proc/12345/cwd\*(R", useful to find the contents of \fIcommand\fR's working
directory, but not its name)
.ie n .IP "$text = $f \-> cumulative_output" 4
.el .IP "\f(CW$text\fR = \f(CW$f\fR \-> cumulative_output" 4
.IX Item "$text = $f -> cumulative_output"
return the current cumulative output. All (untreated) output gets
appended to the cumulative output after the output_handler has been
called. The cumulative output starts with a fresh slate with every
\&\s-1OUTPUT\s0 message that directly follows an \s-1INPUT\s0 message (ignoring out-of-band
messages and rejected prompts)
.Sp
When necessary (i.e. when \fBrlwrap\fR is in \*(L"impatient mode\*(R") the prompt
is removed from \f(CW$filter\fR\->cumulative_output by the time the prompt
handler is called.
.ie n .IP "$tag = $f \-> previous_tag" 4
.el .IP "\f(CW$tag\fR = \f(CW$f\fR \-> previous_tag" 4
.IX Item "$tag = $f -> previous_tag"
The tag of the last preceding in-band message. A tag is an integer between 0 and
255, its name can be found with the following method:
.ie n .IP "$name = $f \-> tag2name($tag)" 4
.el .IP "\f(CW$name\fR = \f(CW$f\fR \-> tag2name($tag)" 4
.IX Item "$name = $f -> tag2name($tag)"
Convert the tag (an integer) to its name (e.g. \*(L"\s-1TAG_PROMPT\*(R"\s0)
.ie n .IP "$name = $f \-> name2tag($tag)" 4
.el .IP "\f(CW$name\fR = \f(CW$f\fR \-> name2tag($tag)" 4
.IX Item "$name = $f -> name2tag($tag)"
Convert a valid tag name like \*(L"\s-1TAG_PROMPT\*(R"\s0 to a tag (an integer)
.ie n .IP "$f \-> send_output_oob($text)" 4
.el .IP "\f(CW$f\fR \-> send_output_oob($text)" 4
.IX Item "$f -> send_output_oob($text)"
Make rlwrap display \f(CW$text\fR. \f(CW$text\fR is sent \*(L"out-of-band\*(R":
\&\fBrlwrap\fR will not see it until just  after it has sent the next
message to the filter
.ie n .IP "$f \-> send_ignore_oob($text)" 4
.el .IP "\f(CW$f\fR \-> send_ignore_oob($text)" 4
.IX Item "$f -> send_ignore_oob($text)"
Send an out-of-band \s-1TAG_IGNORE\s0 message to rlwrap. \fBrlwrap\fR will silently
discard it, but it can be useful when debugging filters
.ie n .IP "$f \-> add_to_completion_list(@words)" 4
.el .IP "\f(CW$f\fR \-> add_to_completion_list(@words)" 4
.IX Item "$f -> add_to_completion_list(@words)"
.PD 0
.ie n .IP "$f \-> remove_from_completion_list(@words)" 4
.el .IP "\f(CW$f\fR \-> remove_from_completion_list(@words)" 4
.IX Item "$f -> remove_from_completion_list(@words)"
.PD
Permanently add or remove the words in \f(CW@words\fR to/from rlwrap's completion list.
.ie n .IP "$f \-> cloak_and_dagger($question, $prompt, $timeout);" 4
.el .IP "\f(CW$f\fR \-> cloak_and_dagger($question, \f(CW$prompt\fR, \f(CW$timeout\fR);" 4
.IX Item "$f -> cloak_and_dagger($question, $prompt, $timeout);"
Send \f(CW$question\fR to \fIcommand\fR's input and read back everything that
comes back until \f(CW$prompt\fR is seen at \*(L"end-of-chunk\*(R", or no new
chunks arrive for \f(CW$timeout\fR seconds, whichever comes first.  Return the
response (without the final \f(CW$prompt\fR).  \fBrlwrap\fR remains completely
unaware of this conversation.
.ie n .IP "$f \-> cloak_and_dagger_verbose($verbosity)" 4
.el .IP "\f(CW$f\fR \-> cloak_and_dagger_verbose($verbosity)" 4
.IX Item "$f -> cloak_and_dagger_verbose($verbosity)"
If \f(CW$verbosity\fR evaluates to a true value, make rlwrap print all
questions sent to \fIcommand\fR by the \f(CW\*(C`cloak_and_dagger\*(C'\fR method, and
\&\fIcommand\fR's responses. By default, \f(CW$verbosity\fR = 0; setting it to
1 will mess up the screen but greatly facilitate the (otherwise rather tricky) use of
\&\f(CW\*(C`cloak_and_dagger\*(C'\fR
.ie n .IP "$self \-> prompt_rejected" 4
.el .IP "\f(CW$self\fR \-> prompt_rejected" 4
.IX Item "$self -> prompt_rejected"
A special text (\*(L"_THIS_CANNOT_BE_A_PROMPT_\*(R") to be returned by a
prompt handler to \*(L"reject\*(R" the prompt. This will make rlwrap skip
cooking the prompt.  \f(CW$self\fR\->previous_tag and \f(CW$self\fR\->cumulative_output
will not be touched.
.ie n .IP "$text = $f \-> prompts_are_never_empty($val)" 4
.el .IP "\f(CW$text\fR = \f(CW$f\fR \-> prompts_are_never_empty($val)" 4
.IX Item "$text = $f -> prompts_are_never_empty($val)"
If \f(CW$val\fR evaluates to a true value, automatically reject empty prompts.
.ie n .IP "$f \-> command_line" 4
.el .IP "\f(CW$f\fR \-> command_line" 4
.IX Item "$f -> command_line"
In scalar context: the rlwrapped command and its arguments as a string (\*(L"command \-v blah\*(R")
in list context: the same as a list (\*(L"command\*(R", \*(L"\-v\*(R", \*(L"blah\*(R")
.ie n .IP "$f \-> running_under_rlwrap" 4
.el .IP "\f(CW$f\fR \-> running_under_rlwrap" 4
.IX Item "$f -> running_under_rlwrap"
Whether the filter is run by \fBrlwrap\fR, or directly from the command line
.ie n .IP "$f \-> run" 4
.el .IP "\f(CW$f\fR \-> run" 4
.IX Item "$f -> run"
Start an event loop that reads rlwrap's messages from the input pipe,
calls the appropriate handlers and writes the result to the output
pipe.  This method never returns.
.SH "LOW LEVEL PROTOCOL"
.IX Header "LOW LEVEL PROTOCOL"
\&\fBrlwrap\fR communicates with a filter through messages consisting of a tag
byte (\s-1TAG_OUTPUT, TAG_PROMPT\s0 etc. \- to inform the filter of what is
being sent), an unsigned 32\-bit integer containing the length of the
message, the message text and an extra newline. For every message
sent, rlwrap expects, and waits for an answer message with the same
tag. Sending back a different (in-band) tag is an error and instantly
kills rlwrap, though filters may precede their answer message with
\&\*(L"out-of-band\*(R" messages to output text (\s-1TAG_OUTPUT_OUT_OF_BAND\s0), report
errors (\s-1TAG_ERROR\s0), and to manipulate the completion word list
(\s-1TAG_ADD_TO_COMPLETION_LIST\s0 and \s-1TAG_REMOVE_FROM_COMPLETION_LIST\s0)
Out-of-band messages are not serviced by \fBrlwrap\fR until right after
it has sent the next in-band message \- the communication with the
filter is synchronous and driven by rlwrap.
.PP
Messages are received and sent via two pipes. \s-1STDIN, STDOUT\s0 and \s-1STDERR\s0
are still connected to the user's terminal, and you can read and write
them directly, though this may mess up the screen and confuse the user
unless you are careful. A filter can even communicate with the
rlwrapped command behind rlwrap's back (cf the \fIcloak_and_dagger()\fR
method)
.PP
The protocol uses the following tags (tags > 128 are out-of-band)
.PP
.Vb 5
\& TAG_INPUT       0
\& TAG_OUTPUT      1
\& TAG_HISTORY     2
\& TAG_COMPLETION  3
\& TAG_PROMPT      4
\&
\& TAG_IGNORE                      251
\& TAG_ADD_TO_COMPLETION_LIST      252
\& TAG_REMOVE_FROM_COMPLETION_LIST 253
\& TAG_OUTPUT_OUT_OF_BAND          254
\& TAG_ERROR                       255
.Ve
.PP
To see how this works, you can eavesdrop on the protocol
using the 'logger' filter.
.PP
The constants \s-1TAG_INPUT, ...\s0 are exported by the RlwrapFilter.pm module.
.SH "SIGNALS"
.IX Header "SIGNALS"
As \s-1STDIN\s0 is still connected to the users teminal, one might expect the filter
to receive \s-1SIGINT, SIGTERM, SIGTSTP\s0 directly from the terminal driver if
the user presses CTRL-C, CTRL-Z etc Normally, we don't want this \- it
would confuse rlwrap, and the user (who thinks she is talking straight
to the rlwapped command) probably meant those signals to be sent to
the command itself. For this reason the filter starts with all signals blocked.
.PP
Filters that interact with the users terminal (e.g. to run a pager)
should unblock signals like \s-1SIGTERM, SIGWINCH.\s0
.SH "FILTER LIFETIME"
.IX Header "FILTER LIFETIME"
The filter is started by \fBrlwrap\fR after \fIcommand\fR, and stays alive
as long as \fBrlwrap\fR runs. Filter methods are immediately usable. When
\&\fIcommand\fR exits, the filter stays around for a little longer in order
to process \fIcommand\fR's last words. As calling the cwd and
cloak_and_dagger methods at that time will make the filter die with an
error, it may be advisable to wrap those calls in eval{}
.PP
If a filter calls \fIdie()\fR it will send an (out-of-band) \s-1TAG_ERROR\s0
message to rlwrap before exiting. rlwrap will then report the message
and exit (just after its next in-band message \- out-of-band messages
are not always processed immediately)
.PP
\&\fIdie()\fR within an \fIeval()\fR sets $@ as usual.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
Before calling a filter, \fBrlwrap\fR sets the following environment variables:
.PP
.Vb 2
\&    RLWRAP_FILTERDIR      directory where RlwrapFilter.pm and most filters live (set by B<rlwrap>, can be
\&                          overridden by the user before calling rlwrap)
\&
\&    PATH                  rlwrap automatically adds $RLWRAP_FILTERDIR to the front of filter\*(Aqs PATH
\&
\&    RLWRAP_VERSION        rlwrap version (e.g. "0.35")
\&
\&    RLWRAP_COMMAND_PID    process ID of the rlwrapped command
\&
\&    RLWRAP_COMMAND_LINE   command line of the rlwrapped command
\&
\&    RLWRAP_IMPATIENT      whether rlwrap is in "impatient mode" (cf B<rlwrap (1)>). In impatient mode,
\&                          the candidate prompt is filtered through the output handler (and displayed before
\&                          being overwritten by the cooked prompt).
\&
\&    RLWRAP_INPUT_PIPE_FD  File descriptor of input pipe. For internal use only
\&
\&    RLWRAP_OUTPUT_PIPE_FD File descriptor of output pipe. For internal use only
\&
\&    RLWRAP_MASTER_PTY_FD File descriptor of I<command>\*(Aqs pty.
.Ve
.SH "DEBUGGING FILTERS"
.IX Header "DEBUGGING FILTERS"
While RlwrapFilter.pm makes it easy to write simple filters, debugging
them can be a problem. A couple of useful tricks:
.SS "\s-1LOGGING\s0"
.IX Subsection "LOGGING"
When running a filter, the in\- and outgoing messages can be logged by
the \fBlogger\fR filter, using a pipeline:
.PP
.Vb 1
\&  rlwrap \-z \*(Aqpipeline logger incoming : my_filter : logger outgoing\*(Aq command
.Ve
.SS "\s-1RUNNING WITHOUT \s0\fBrlwrap\fP"
.IX Subsection "RUNNING WITHOUT rlwrap"
When called by rlwrap, filters get their input from
\&\f(CW$RLWRAP_INPUT_PIPE_FD\fR and write their output to
\&\f(CW$RLWRAP_OUTPUT_PIPE_FD\fR, and expect and write messages consisting of a
tag byte, a 32\-bit length and the message proper. This is not terribly
useful when running a filter directly from the command line (outside
rlwrap), even if we set the RLWRAP_*_FD ourselves.
.PP
Therefore, when run directly from the command line, a filter expects
input messages on its standard input of the form
.PP
\&\s-1TAG_PROMPT\s0 myprompt >
.PP
(i.a. a tag name, one space and a message followed by a newline) and it will respond in the
same way on its standard output
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBrlwrap\fR (1), \fBreadline\fR (3)
